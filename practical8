class Item:
    def __init__(self, weight, profit):
        self.weight = weight
        self.profit = profit
        self.ratio = profit / weight  # Profit-to-weight ratio


def fractionalKnapsack(items, capacity):
    # Sort items by descending profit/weight ratio
    items.sort(key=lambda x: x.ratio, reverse=True)

    total_profit = 0.0
    remaining_capacity = capacity

    print("Selected parcels (weight, profit):")

    for item in items:
        if remaining_capacity == 0:
            break

        # If the item can be fully taken
        if item.weight <= remaining_capacity:
            remaining_capacity -= item.weight
            total_profit += item.profit
            print(f"  Full Item: Weight={item.weight}, Profit={item.profit}")
        else:
            # Take the fractional part
            fraction = remaining_capacity / item.weight
            total_profit += item.profit * fraction
            print(f"  Partial Item: Weight={item.weight * fraction:.2f}, Profit={item.profit * fraction:.2f}")
            remaining_capacity = 0

    return total_profit


# Driver code
if __name__ == "__main__":
    n = int(input("Enter number of parcels: "))
    items = []

    for i in range(n):
        weight = float(input(f"Enter weight of parcel {i + 1}: "))
        profit = float(input(f"Enter profit of parcel {i + 1}: "))
        items.append(Item(weight, profit))

    capacity = float(input("Enter truck capacity: "))

    max_profit = fractionalKnapsack(items, capacity)
    print(f"\nMaximum Profit that can be obtained: {max_profit:.2f}")
